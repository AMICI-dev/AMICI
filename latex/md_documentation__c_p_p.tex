The \mbox{\hyperlink{python_interface}{Python Interface}} and \mbox{\hyperlink{matlab_interface}{M\+A\+T\+L\+AB Interface}} can translate the model definition into C++ code, which is then compiled into a {\ttfamily .mex} file or a Python module. Advanced users can also use this code within stand-\/alone C/\+C++ application for use in other environments (e.\+g. on high performance computing systems). This section will give a short overview over the generated files and provide a brief introduction of how this code can be included in other applications. For more details see the function level documentation, e.\+g. in \href{http://icb-dcm.github.io/AMICI/amici_8cpp.html}{\texttt{ http\+://icb-\/dcm.\+github.\+io/\+A\+M\+I\+C\+I/amici\+\_\+8cpp.\+html}}.\hypertarget{md_documentation__c_p_p_autotoc_md75}{}\doxysubsection{Generation of C++ model files}\label{md_documentation__c_p_p_autotoc_md75}
{\ttfamily \mbox{\hyperlink{amiwrap_8m}{amiwrap.\+m}}} (Matlab) and {\ttfamily amici.\+Sbml\+Importer.\+sbml2amici} (Python) import a model and create C++ code for various model functions. The model source files are written to {\ttfamily \$\{A\+M\+I\+C\+I\+\_\+\+R\+O\+O\+T\+\_\+\+D\+IR\}/models/\$\{M\+O\+D\+E\+L\+\_\+\+N\+A\+ME\}} by default.

The content of a model source directory might look something like this (given {\ttfamily M\+O\+D\+E\+L\+\_\+\+N\+A\+ME=model\+\_\+steadystate})\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{CMakeLists.txt}
\DoxyCodeLine{hashes.mat }
\DoxyCodeLine{main.cpp }
\DoxyCodeLine{model\_steadystate\_deltaqB.cpp }
\DoxyCodeLine{model\_steadystate\_deltaqB.h }
\DoxyCodeLine{[... many more files model\_steadystate\_*.(cpp|h|md5|o) ]}
\DoxyCodeLine{wrapfunctions.cpp }
\DoxyCodeLine{wrapfunctions.h }
\DoxyCodeLine{model\_steadystate.h }
\end{DoxyCode}


These files provide the implementation of a model-\/specific subclass of {\ttfamily \mbox{\hyperlink{classamici_1_1_model}{amici\+::\+Model}}}. The {\ttfamily C\+Make\+Lists.\+txt} file can be used to build the library. {\ttfamily main.\+cpp} contains a simple scaffold for running a model simulation from C++. See next section for more details on these files.\hypertarget{md_documentation__c_p_p_autotoc_md76}{}\doxysubsection{Compiling and linking}\label{md_documentation__c_p_p_autotoc_md76}
In your application, you need to compile and link every model {\ttfamily \$\{A\+M\+I\+C\+I\+\_\+\+R\+O\+O\+T\+\_\+\+D\+IR\}/models/\$\{M\+O\+D\+E\+L\+\_\+\+N\+A\+ME\}/$\ast$.cpp}, {\ttfamily \$\{A\+M\+I\+C\+I\+\_\+\+R\+O\+O\+T\+\_\+\+D\+IR\}/src/$\ast$.cpp}, the S\+U\+N\+D\+I\+A\+LS and the Suite\+Sparse library. The simplest and recommended way is using the C\+Make package configuration from the build directory ({\ttfamily Amici\+Config.\+cmake} for use with \href{https://cmake.org/cmake/help/latest/command/find_package.html}{\texttt{ {\ttfamily find\+\_\+package}}} which tells C\+Make about all A\+M\+I\+CI dependencies.

During model import a \href{https://cmake.org/}{\texttt{ C\+Make}} file ({\ttfamily C\+Make\+Lists.\+txt}) will be generated automatically. The C\+Make file shows the above-\/mentioned library dependencies. {\ttfamily C\+Make\+Lists.\+txt}, together with {\ttfamily main.\+cpp}, provides a scaffold for a standalone simulation program. The required numerical libraries are shipped with A\+M\+I\+CI. To compile them, run {\ttfamily \$\{A\+M\+I\+C\+I\+\_\+\+R\+O\+O\+T\+\_\+\+D\+IR\}/scripts/build\+All.sh} once. H\+D\+F5 libraries and header files need to be installed separately (see A\+M\+I\+CI installation instructions).

More information on how to run the compiled sample program is provided in {\ttfamily main.\+cpp}.

The file {\ttfamily wrapfunctions.\+h} exports some functions with generic names e.\+g. to create a model instance. These functions are meant to be used by applications which may be linked to single, potentially changing model to avoid hard-\/coding the model name. Including multiple {\ttfamily wrapfunctions.\+h} files from different models at once is not possible.\hypertarget{md_documentation__c_p_p_autotoc_md77}{}\doxysubsection{Running a simulation}\label{md_documentation__c_p_p_autotoc_md77}
The complete A\+M\+I\+CI A\+PI is available through {\ttfamily \mbox{\hyperlink{amici_8h_source}{amici/amici.\+h}}}; this is the only header file that needs to be included for basic usage. Additionally, {\ttfamily \mbox{\hyperlink{hdf5_8h_source}{amici/hdf5.\+h}}} may be helpful. This file provides some functions for reading and writing \href{https://support.hdfgroup.org/}{\texttt{ H\+D\+F5}} files). All functions are declared within the {\ttfamily amici} namespace.

The entry function for running an A\+M\+I\+CI simulation is {\ttfamily amici\+::run\+Amici\+Simulation(...)}, declared in {\ttfamily \mbox{\hyperlink{amici_8h_source}{amici/amici.\+h}}}.

This function requires


\begin{DoxyItemize}
\item a {\ttfamily \mbox{\hyperlink{classamici_1_1_model}{amici\+::\+Model}}} instance. For the example {\ttfamily model\+\_\+steadystate} the respective class is provided as {\ttfamily Model\+\_\+model\+\_\+steadystate} in {\ttfamily model\+\_\+steadystate.\+h}. For convenience, the header {\ttfamily wrapfunctions.\+h} defines a function {\ttfamily get\+Model()}, that returns an instance of that class.
\item a {\ttfamily \mbox{\hyperlink{classamici_1_1_solver}{amici\+::\+Solver}}} instance. This solver instance needs to match the requirements of the model and can be generated using {\ttfamily model-\/$>$get\+Solver()}.
\item optionally an {\ttfamily \mbox{\hyperlink{classamici_1_1_exp_data}{amici\+::\+Exp\+Data}}} instance, which contains any experimental data (e.\+g. measurements, noise model parameters or model inputs) to compute residuals or an objective function.
\end{DoxyItemize}

A scaffold for a standalone simulation program is generated in {\ttfamily main.\+cpp} in the model source directory. This program shows how to use the above-\/mentioned classes and how to obtain the simulation results.

For running simulations for multiple experimental conditions (multiple {\ttfamily \mbox{\hyperlink{classamici_1_1_exp_data}{amici\+::\+Exp\+Data}}} instances), {\ttfamily amici\+::run\+Amici\+Simulations(...)} provides an alternative entry point. If A\+M\+I\+CI (and your application) have been compiled with Open\+MP support (see installation guide), this allows for running those simulations in parallel.\hypertarget{md_documentation__c_p_p_autotoc_md78}{}\doxysubsection{Parameter estimation for A\+M\+I\+C\+I models in high-\/performance computing environments}\label{md_documentation__c_p_p_autotoc_md78}
To perform parameter estimation for large or otherwise computationally demanding A\+M\+I\+CI models from C++ in a high-\/performance computing environment, you may find the \href{https://github.com/ICB-DCM/parPE/}{\texttt{ par\+PE}} library helpful. par\+PE allows for the private or shared memory parallel evaluation of a cost function requiring multiple simulations of the same model with different inputs. It provides interfaces to different optimizers, such as Ipopt. 