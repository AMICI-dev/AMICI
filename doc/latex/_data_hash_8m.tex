\hypertarget{_data_hash_8m}{}\subsection{auxiliary/datahash/\+Data\+Hash.m File Reference}
\label{_data_hash_8m}\index{auxiliary/datahash/\+Data\+Hash.\+m@{auxiliary/datahash/\+Data\+Hash.\+m}}


D\+A\+T\+A\+H\+A\+S\+H -\/ Checksum for Matlab array of any type This function creates a hash value for an input of any type. The type and dimensions of the input are considered as default, such that U\+I\+N\+T8(\mbox{[}0,0\mbox{]}) and U\+I\+N\+T16(0) have different hash values. Nested S\+T\+R\+U\+C\+Ts and C\+E\+L\+Ls are parsed recursively.  


\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
mlhs\+Inner\+Subst$<$ matlabtypesubstitute $>$ \hyperlink{_data_hash_8m_a4c7237b24544ef3ff686d60f76ff1dd7}{Data\+Hash} (matlabtypesubstitute Data, matlabtypesubstitute Opt)
\begin{DoxyCompactList}\small\item\em D\+A\+T\+A\+H\+A\+S\+H -\/ Checksum for Matlab array of any type This function creates a hash value for an input of any type. The type and dimensions of the input are considered as default, such that U\+I\+N\+T8(\mbox{[}0,0\mbox{]}) and U\+I\+N\+T16(0) have different hash values. Nested S\+T\+R\+U\+C\+Ts and C\+E\+L\+Ls are parsed recursively. \end{DoxyCompactList}\item 
\hypertarget{_data_hash_8m_a419ad6fb38134382c61205038abcc5ed}{}mlhs\+Inner\+Subst$<$ matlabtypesubstitute $>$ \hyperlink{_data_hash_8m_a419ad6fb38134382c61205038abcc5ed}{mtoc\+\_\+subst\+\_\+\+Data\+Hash\+\_\+m\+\_\+tsbus\+\_\+cotm\+\_\+\+Core\+Hash\+\_\+} (matlabtypesubstitute Data, matlabtypesubstitute Engine)\label{_data_hash_8m_a419ad6fb38134382c61205038abcc5ed}

\begin{DoxyCompactList}\small\item\em This method uses the faster typecastx version. \end{DoxyCompactList}\item 
\hypertarget{_data_hash_8m_a76b5820ab49a9784a824ab982aa072ce}{}mlhs\+Inner\+Subst$<$ matlabtypesubstitute $>$ \hyperlink{_data_hash_8m_a76b5820ab49a9784a824ab982aa072ce}{mtoc\+\_\+subst\+\_\+\+Data\+Hash\+\_\+m\+\_\+tsbus\+\_\+cotm\+\_\+\+Core\+Hash} (matlabtypesubstitute Data, matlabtypesubstitute Engine)\label{_data_hash_8m_a76b5820ab49a9784a824ab982aa072ce}

\begin{DoxyCompactList}\small\item\em This methods uses the slower T\+Y\+P\+E\+C\+A\+S\+T of Matlab See Core\+Hash\+\_\+ for comments. \end{DoxyCompactList}\item 
\hypertarget{_data_hash_8m_a9f37c34f88e4648930ff5613745509d1}{}mlhs\+Inner\+Subst$<$ matlabtypesubstitute $>$ \hyperlink{_data_hash_8m_a9f37c34f88e4648930ff5613745509d1}{mtoc\+\_\+subst\+\_\+\+Data\+Hash\+\_\+m\+\_\+tsbus\+\_\+cotm\+\_\+\+Convert\+Func\+Handle} (matlabtypesubstitute Func\+H)\label{_data_hash_8m_a9f37c34f88e4648930ff5613745509d1}

\begin{DoxyCompactList}\small\item\em The subfunction Convert\+Func\+Handle converts function\+\_\+handles to a struct using the Matlab function F\+U\+N\+C\+T\+I\+O\+N\+S. The output of this function changes with the Matlab version, such that Data\+Hash() replies different hashes under Matlab 6.\+5 and 2009a. An alternative is using the function name and name of the file for function\+\_\+handles, but this is not unique for nested or anonymous functions. If the M\+A\+T\+L\+A\+B\+R\+O\+O\+T is removed from the file\textquotesingle{}s path, at least the hash of Matlab\textquotesingle{}s toolbox functions is (usually!) not influenced by the version. Finally I\textquotesingle{}m in doubt if there is a unique method to hash function handles. Please adjust the subfunction Convert\+Func\+Handles to your needs. \end{DoxyCompactList}\item 
\hypertarget{_data_hash_8m_abf72c38b79d0ef24bf70d24ceef525c3}{}mlhs\+Inner\+Subst$<$ matlabtypesubstitute $>$ \hyperlink{_data_hash_8m_abf72c38b79d0ef24bf70d24ceef525c3}{mtoc\+\_\+subst\+\_\+\+Data\+Hash\+\_\+m\+\_\+tsbus\+\_\+cotm\+\_\+\+Convert\+Object} (matlabtypesubstitute Data\+Obj)\label{_data_hash_8m_abf72c38b79d0ef24bf70d24ceef525c3}

\begin{DoxyCompactList}\small\item\em Convert a user-\/defined object to a binary stream. There cannot be a unique solution, so this part is left for the user... \end{DoxyCompactList}\item 
\hypertarget{_data_hash_8m_ad58dae0cbccd5a6498a386cafab23f56}{}mlhs\+Inner\+Subst$<$ matlabtypesubstitute $>$ \hyperlink{_data_hash_8m_ad58dae0cbccd5a6498a386cafab23f56}{mtoc\+\_\+subst\+\_\+\+Data\+Hash\+\_\+m\+\_\+tsbus\+\_\+cotm\+\_\+f\+Base64\+\_\+enc} (matlabtypesubstitute In)\label{_data_hash_8m_ad58dae0cbccd5a6498a386cafab23f56}

\begin{DoxyCompactList}\small\item\em Encode numeric vector of U\+I\+N\+T8 values to base64 string. The intention of this is to create a shorter hash than the H\+E\+X format. Therefore a padding with {\ttfamily =} characters is omitted on purpose. \end{DoxyCompactList}\item 
\hypertarget{_data_hash_8m_a9440e0bc7ccfbd27d400af2bb75d6e63}{}mlhs\+Inner\+Subst$<$ matlabtypesubstitute $>$ \hyperlink{_data_hash_8m_a9440e0bc7ccfbd27d400af2bb75d6e63}{mtoc\+\_\+subst\+\_\+\+Data\+Hash\+\_\+m\+\_\+tsbus\+\_\+cotm\+\_\+\+File\+Exist} (matlabtypesubstitute File\+Name)\label{_data_hash_8m_a9440e0bc7ccfbd27d400af2bb75d6e63}

\begin{DoxyCompactList}\small\item\em A more reliable version of E\+X\+I\+S\+T(File\+Name, {\ttfamily file})\+: \end{DoxyCompactList}\item 
\hypertarget{_data_hash_8m_aa48e03c93fc20fd9aec8522846f24f7f}{}noret\+::substitute {\bfseries mtoc\+\_\+subst\+\_\+\+Data\+Hash\+\_\+m\+\_\+tsbus\+\_\+cotm\+\_\+\+Error\+\_\+\+L} (matlabtypesubstitute I\+D, matlabtypesubstitute varargin)\label{_data_hash_8m_aa48e03c93fc20fd9aec8522846f24f7f}

\end{DoxyCompactItemize}


\subsubsection{Function Documentation}
\hypertarget{_data_hash_8m_a4c7237b24544ef3ff686d60f76ff1dd7}{}\index{Data\+Hash.\+m@{Data\+Hash.\+m}!Data\+Hash@{Data\+Hash}}
\index{Data\+Hash@{Data\+Hash}!Data\+Hash.\+m@{Data\+Hash.\+m}}
\paragraph[{Data\+Hash(matlabtypesubstitute Data, matlabtypesubstitute Opt)}]{\setlength{\rightskip}{0pt plus 5cm}mlhs\+Inner\+Subst$<$ matlabtypesubstitute $>$ Data\+Hash (
\begin{DoxyParamCaption}
\item[{matlabtypesubstitute}]{Data, }
\item[{matlabtypesubstitute}]{Opt}
\end{DoxyParamCaption}
)}\label{_data_hash_8m_a4c7237b24544ef3ff686d60f76ff1dd7}
Hash = Data\+Hash(\+Data, Opt) \begin{DoxyParagraph}{I\+N\+P\+U\+T}

\end{DoxyParagraph}
\begin{DoxyParagraph}{Data\+: Array of these built-\/in types}
(U)I\+N\+T8/16/32/64, S\+I\+N\+G\+L\+E, D\+O\+U\+B\+L\+E, (real/complex, full/sparse) C\+H\+A\+R, L\+O\+G\+I\+C\+A\+L, C\+E\+L\+L (nested), S\+T\+R\+U\+C\+T (scalar or array, nested), function\+\_\+handle. Opt\+: Struct to specify the hashing algorithm and the output format. Opt and all its fields are optional. 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Opt.Method\+: String, known methods for Java 1.6 (Matlab 2009a)}
{\ttfamily S\+H\+A-\/1}, {\ttfamily S\+H\+A-\/256}, {\ttfamily S\+H\+A-\/384}, {\ttfamily S\+H\+A-\/512}, {\ttfamily M\+D2}, {\ttfamily M\+D5}. 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Known methods for Java 1.3 (Matlab 6.5)}
{\ttfamily M\+D5}, {\ttfamily S\+H\+A-\/1}. Default\+: {\ttfamily M\+D5}. 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Opt.Format\+: String specifying the output format}
{\ttfamily hex}, {\ttfamily H\+E\+X}\+: Lower/uppercase hexadecimal string. {\ttfamily double}, {\ttfamily uint8}\+: Numerical vector. {\ttfamily base64}\+: Base64 encoded string, only printable A\+S\+C\+I\+I characters, shorter than {\ttfamily hex}, no padding. Default\+: {\ttfamily hex}. 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Opt.Input\+: Type of the input as string, not case-\/sensitive}
{\ttfamily array}\+: The contents, type and size of the input \mbox{[}Data\mbox{]} are considered for the creation of the hash. Nested C\+E\+L\+Ls and S\+T\+R\+U\+C\+T arrays are parsed recursively. Empty arrays of different type reply different hashs. {\ttfamily file}\+: \mbox{[}Data\mbox{]} is treated as file name and the hash is calculated for the files contents. {\ttfamily bin}\+: \mbox{[}Data\mbox{]} is a numerical, L\+O\+G\+I\+C\+A\+L or C\+H\+A\+R array. Only the binary contents of the array is considered, such that e.\+g. empty arrays of different type reply the same hash. {\ttfamily ascii}\+: Same as {\ttfamily bin}, but only the 8-\/bit A\+S\+C\+I\+I part of the 16-\/bit Matlab C\+H\+A\+Rs is considered. Default\+: {\ttfamily array}.
\end{DoxyParagraph}
\begin{DoxyParagraph}{O\+U\+T\+P\+U\+T}
Hash\+: String, D\+O\+U\+B\+L\+E or U\+I\+N\+T8 vector. The length depends on the hashing method.
\end{DoxyParagraph}
\begin{DoxyParagraph}{E\+X\+A\+M\+P\+L\+E\+S}
\%
\end{DoxyParagraph}
\begin{DoxyParagraph}{Default\+: M\+D5, hex}
Data\+Hash(\mbox{[}$\,$\mbox{]}) \% 240f5f01f052bd89f38da2165dcf25c7 \%
\end{DoxyParagraph}
\begin{DoxyParagraph}{M\+D5, Base64}
Opt = struct({\ttfamily Format}, {\ttfamily base64}, {\ttfamily Method}, {\ttfamily M\+D5}); Data\+Hash(int32(1\+:10), Opt) \% m0\+On/v\+T\+Kh\+J\+Hgb\+L\+Wa3\+A+\+Cdw \%
\end{DoxyParagraph}
\begin{DoxyParagraph}{S\+H\+A-\/1, Base64}
S.\+a = uint8(\mbox{[}$\,$\mbox{]}); S.\+b = \{\{1\+:10\}, struct({\ttfamily q}, uint64(415))\}; Opt.\+Method = {\ttfamily S\+H\+A-\/1}; Opt.\+Format = {\ttfamily H\+E\+X}; Data\+Hash(\+S, Opt) \% 69\+D\+F1\+D743641\+A419\+B22\+F08684234\+F687\+F\+C2\+B6698 \%
\end{DoxyParagraph}
\begin{DoxyParagraph}{S\+H\+A-\/1 of binary values}
Opt = struct({\ttfamily Method}, {\ttfamily S\+H\+A-\/1}, {\ttfamily Input}, {\ttfamily bin}); Data\+Hash(1\+:8, Opt) \% 826cf9d3a5d74bbe415e97d4cecf03f445f69225 \%
\end{DoxyParagraph}
\begin{DoxyParagraph}{S\+H\+A-\/256, consider A\+S\+C\+I\+I part only (Matlab\textquotesingle{}s C\+H\+A\+R has 16 bits!)}
Opt.\+Method = {\ttfamily S\+H\+A-\/256}; Opt.\+Input = {\ttfamily ascii}; Data\+Hash({\ttfamily abc}, Opt) \% ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad \%
\end{DoxyParagraph}
\begin{DoxyParagraph}{Or equivalently}
Opt.\+Input = {\ttfamily bin}; Data\+Hash(uint8({\ttfamily abc}), Opt)
\end{DoxyParagraph}
\begin{DoxyParagraph}{N\+O\+T\+E\+S}

\end{DoxyParagraph}
\begin{DoxyParagraph}{Function handles and user-\/defined objects cannot be converted uniquely}

\begin{DoxyItemize}
\item The subfunction Convert\+Func\+Handle uses the built-\/in function F\+U\+N\+C\+T\+I\+O\+N\+S, but the replied struct can depend on the Matlab version.
\item It is tried to convert objects to U\+I\+N\+T8 streams in the subfunction Convert\+Object. A conversion by S\+T\+R\+U\+C\+T() might be more appropriate. Adjust these subfunctions on demand.
\end{DoxyItemize}
\end{DoxyParagraph}
M\+A\+T\+L\+A\+B C\+H\+A\+Rs have 16 bits! Use Opt.\+Input={\ttfamily ascii} for comparisons with e.\+g. online hash generators.

\begin{DoxyParagraph}{Data\+Hash uses James Tursa\textquotesingle{}s smart and fast T\+Y\+P\+E\+C\+A\+S\+T\+X, if it is installed}
\href{http://www.mathworks.com/matlabcentral/fileexchange/17476}{\tt http\+://www.\+mathworks.\+com/matlabcentral/fileexchange/17476} As fallback the built-\/in T\+Y\+P\+E\+C\+A\+S\+T is used automatically, but for large inputs this can be more than 100 times slower. For Matlab 6.\+5 installing T\+Y\+P\+E\+C\+A\+S\+T\+X is obligatory to run Data\+Hash.
\end{DoxyParagraph}
Tested\+: Matlab 6.\+5, 7.\+7, 7.\+8, 7.\+13, Win\+X\+P/32, Win7/64 Author\+: Jan Simon, Heidelberg, (C) 2011-\/2015 matlab.\+2010(a)n(\+M\+I\+N\+U\+S)simon.\+de

\begin{DoxySeeAlso}{See also}
T\+Y\+P\+E\+C\+A\+S\+T, C\+A\+S\+T. 
\end{DoxySeeAlso}
\begin{DoxyParagraph}{In Matlab\textquotesingle{}s File\+Exchange}

\end{DoxyParagraph}
\begin{DoxyParagraph}{Michael Kleder, \char`\"{}\+Compute Hash\char`\"{}, no structs and cells}
\href{http://www.mathworks.com/matlabcentral/fileexchange/8944}{\tt http\+://www.\+mathworks.\+com/matlabcentral/fileexchange/8944} 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Tim, \char`\"{}\+Serialize/\+Deserialize\char`\"{}, converts structs and cells to a byte stream}
\href{http://www.mathworks.com/matlabcentral/fileexchange/29457}{\tt http\+://www.\+mathworks.\+com/matlabcentral/fileexchange/29457} 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Jan Simon, \char`\"{}\+Calc\+M\+D5\char`\"{}, M\+D5 only, fast C-\/mex}
\href{http://www.mathworks.com/matlabcentral/fileexchange/25921}{\tt http\+://www.\+mathworks.\+com/matlabcentral/fileexchange/25921} 
\end{DoxyParagraph}


Definition at line 17 of file Data\+Hash.\+m.



Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=294pt]{_data_hash_8m_a4c7237b24544ef3ff686d60f76ff1dd7_icgraph}
\end{center}
\end{figure}


