/**
 @page code Code Organization
 
 In the following we will briefly outline what happens when a model is compiled. For a more detailed description we refer the reader to the documentation of the individual functions.
 
 After specifying a model (see @ref definition) the user will typically compile the model by invoking amiwrap(). amiwrap() first instantiates an object of the class @ref amimodel. The properties of this object are initialised based on the user-defined model. If the o2flag is active, all subsequent computations will also be carried out on the augmented system, which also includes the equations for forward sensitivities. This allows the computation of second order sensitivities in a forward-forward approach. A forward-adjoint approach will be implemented in the future.
 
 The sym and fun fields of this object will then be populated by amimodel::parseModel(). The amimodel::sym field contains all necessary symbolic expression while the amimodel::fun field will contain flags for all functions whether the C code for a certain function needs to be regenerated or not. The set of functions to be considered will depend on the user specification of the model fields amimodel::adjoint and amimodel::forward (see @ref options) as well as the employed solver (CVODES or IDAS, see @ref rhs). For all considered functions amimodel::parseModel() will check their dependencies via amimodel::checkDeps(). These dependencies are a subset of the user-specified fields of amimodel::sym (see @ref attach). amimodel::parseModel() compares the hashes of all dependencies against the amimodel::HTable of possible previous compilations and will only compute necessary symbolic expressions if changes in these fields occured. If changes in the dependencies occured, also the respective subfield in amimodel::fun be set to 1, indicating the necessity of regeneration of respective C code.
 
 For all functions for which amimodel::fun is set to 1, amimodel::generateC() will generate C files. These files together with their respective header files will be placed in $AMICIDIR/models/<i>modelname</i>. amimodel::generateC() will also generate wrapfunctions.h and wrapfunctions.c. These files define and declare model unspecific wrapper functions around model specific functions. This construction allows us to use to build multiple different models against the same simulation routines by linking different realisations of these wrapper functions.
 
 All the generated C functions are subsequently compiled by amimodel::compileC(). For all functions individual object files are created to reduce the computation cost of code optimization. Moreover necessary code from sundials and SuiteSparse is compiled as object files and placed in /models/<i>mexext</i>, where mexext stands for the string returned by matlab to the command mexext. The mex simulation file is compiled from amiwrap.c, linked against all object necessary of sundials, SuiteSparse and model specific functions. Depending on the required solver, the compilation will either include cvodewrap.h or idawrap.h. These files implement solver specific realisations of the AMI... functions used in amiwrap.c and amici.c. This allows the use of the same simulation routines for both CVODES and IDAS.

 
 */
