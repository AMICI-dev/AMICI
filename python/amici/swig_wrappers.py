"""Convenience wrappers for the swig interface"""
import sys
from contextlib import contextmanager, suppress
from typing import List, Optional, Union

import amici
from amici import (AmiciExpData, AmiciExpDataVector, AmiciModel,
                   AmiciReturnData, AmiciSolver, ReturnDataView)
from . import numpy

try:
    from wurlitzer import sys_pipes
except ModuleNotFoundError:
    sys_pipes = suppress


@contextmanager
def _capture_cstdout():
    """Redirect C/C++ stdout to python stdout if python stdout is redirected,
    e.g. in ipython notebook"""
    if sys.stdout == sys.__stdout__:
        yield
    else:
        with sys_pipes():
            yield


def _get_ptr(
        obj: Union[AmiciModel, AmiciExpData, AmiciSolver, AmiciReturnData]
) -> Union['amici.Model', 'amici.ExpData', 'amici.Solver', 'amici.ReturnData']:
    """
    Convenience wrapper that returns the smart pointer pointee, if applicable

    :param obj:
        Potential smart pointer

    :returns:
        Non-smart pointer
    """
    if isinstance(obj, (amici.ModelPtr, amici.ExpDataPtr, amici.SolverPtr,
                        amici.ReturnDataPtr)):
        return obj.get()
    return obj


def runAmiciSimulation(
        model: AmiciModel,
        solver: AmiciSolver,
        edata: Optional[AmiciExpData] = None
) -> 'numpy.ReturnDataView':
    """
    Convenience wrapper around :py:func:`amici.amici.runAmiciSimulation`
    (generated by swig)

    :param model:
        Model instance

`   :param solver:
        Solver instance, must be generated from
        :py:meth:`amici.amici.Model.getSolver`

    :param edata:
        ExpData instance (optional)

    :returns:
        ReturnData object with simulation results
    """
    with _capture_cstdout():
        rdata = amici.runAmiciSimulation(_get_ptr(solver), _get_ptr(edata),
                                         _get_ptr(model))
    return numpy.ReturnDataView(rdata)


def ExpData(*args) -> 'amici.ExpData':
    """
    Convenience wrapper for :py:class:`amici.amici.ExpData` constructors

    :param args: arguments

    :returns: ExpData Instance
    """
    if isinstance(args[0], ReturnDataView):
        return amici.ExpData(_get_ptr(args[0]['ptr']), *args[1:])
    elif isinstance(args[0], (amici.ExpData, amici.ExpDataPtr)):
        # the *args[:1] should be empty, but by the time you read this,
        # the constructor signature may have changed, and you are glad this
        # wrapper did not break.
        return amici.ExpData(_get_ptr(args[0]), *args[1:])
    elif isinstance(args[0], (amici.Model, amici.ModelPtr)):
        return amici.ExpData(_get_ptr(args[0]))
    else:
        return amici.ExpData(*args)


def runAmiciSimulations(
        model: AmiciModel,
        solver: AmiciSolver,
        edata_list: AmiciExpDataVector,
        failfast: bool = True,
        num_threads: int = 1,
) -> List['numpy.ReturnDataView']:
    """
    Convenience wrapper for loops of amici.runAmiciSimulation

    :param model: Model instance
    :param solver: Solver instance, must be generated from Model.getSolver()
    :param edata_list: list of ExpData instances
    :param failfast: returns as soon as an integration failure is encountered
    :param num_threads: number of threads to use (only used if compiled
        with openmp)

    :returns: list of simulation results
    """
    with _capture_cstdout():
        edata_ptr_vector = amici.ExpDataPtrVector(edata_list)
        rdata_ptr_list = amici.runAmiciSimulations(_get_ptr(solver),
                                                   edata_ptr_vector,
                                                   _get_ptr(model),
                                                   failfast,
                                                   num_threads)
    return [numpy.ReturnDataView(r) for r in rdata_ptr_list]


def readSolverSettingsFromHDF5(
        file: str,
        solver: AmiciSolver,
        location: Optional[str] = 'solverSettings'
) -> None:
    """
    Convenience wrapper for :py:func:`amici.readSolverSettingsFromHDF5`

    :param file: hdf5 filename
    :param solver: Solver instance to which settings will be transferred
    :param location: location of solver settings in hdf5 file
    """
    amici.readSolverSettingsFromHDF5(file, _get_ptr(solver), location)


def writeSolverSettingsToHDF5(
        solver: AmiciSolver,
        file: Union[str, object],
        location: Optional[str] = 'solverSettings'
) -> None:
    """
    Convenience wrapper for :py:func:`amici.amici.writeSolverSettingsToHDF5`

    :param file: hdf5 filename, can also be an object created by
        :py:func:`amici.amici.createOrOpenForWriting`
    :param solver: Solver instance from which settings will be stored
    :param location: location of solver settings in hdf5 file
    """
    amici.writeSolverSettingsToHDF5(_get_ptr(solver), file, location)
