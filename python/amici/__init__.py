""" @package amici 
The AMICI Python module (in doxygen this will also contain documentation about the C++ library)

The AMICI Python module provides functionality for importing SBML models and turning them into C++ Python extensions.

Getting started:
```
# creating a extension module for an SBML model:
import amici
amiSbml = amici.SbmlImporter('mymodel.sbml')
amiSbml.sbml2amici('modelName', 'outputDirectory')

# using the created module (set python path)
import modelName
help(modelName)
```

Attributes:
    dirname: absolute path to parent directory of this file
    amici_path: absolute root path of the amici repository
    amiciSwigPath: absolute path of the amici swig directory
    amiciSrcPath: absolute path of the amici source directory
    amiciModulePath: absolute root path of the amici module
    hdf5_enabled: boolean indicating if amici was compiled with hdf5 support
    pd: placeholder variable for pandas module
"""

import os
import copy
import numpy as np
try:
    import pandas as pd
except ImportError:
    pd = None

# If this file is inside the amici package, import swig interface,
# otherwise we are inside the git repository, then don't
dirname = os.path.dirname(__file__)
hdf5_enabled = False
if os.path.isfile(os.path.join(dirname, 'amici.py')):
    try:
        from . import amici
        from .amici import *
        hdf5_enabled = True
    except AttributeError:
        from . import amici_without_hdf5 as amici
        from .amici_without_hdf5 import *

# determine package installation path, or, if used directly from git
# repository, get repository root
if os.path.exists(os.path.join(os.path.dirname(__file__), '..', '..', '.git')):
    amici_path = os.path.abspath(os.path.join(
        os.path.dirname(__file__), '..', '..'))
else:
    amici_path = os.path.dirname(__file__)

amiciSwigPath = os.path.join(amici_path, 'swig')
amiciSrcPath = os.path.join(amici_path, 'src')
amiciModulePath = os.path.dirname(__file__)

from .sbml_import import *


def runAmiciSimulation(model, solver, edata=None):
    """ Convenience wrapper around amici.runAmiciSimulation (generated by swig) 

    Arguments:
        model: Model instance
        solver: Solver instance, must be generated from Model.getSolver()
        edata: ExpData instance (optional)

    Returns:
        ReturnData object with simulation results

    Raises:
        
    """
    if edata and edata.__class__.__name__ == 'ExpDataPtr':
        edata = edata.get()

    rdata = amici.runAmiciSimulation(solver.get(), edata, model.get())
    return rdataToNumPyArrays(rdata)

def ExpData(rdata, sigma_y, sigma_z):
    """ Convenience wrapper for ExpData constructor

    Arguments:
        rdata: rdataToNumPyArrays output
        sigma_y: standard deviation for ObservableData
        sigma_z: standard deviation for EventData

    Returns:
        ExpData Instance

    Raises:

    """
    return amici.ExpData(rdata['ptr'].get(), sigma_y, sigma_z)


def runAmiciSimulations(model, solver, edata_list):
    """ Convenience wrapper for loops of amici.runAmiciSimulation

    Arguments:
        model: Model instance
        solver: Solver instance, must be generated from Model.getSolver()
        edata_list: list of ExpData instances (optional)

    Returns:
        list of ReturnData objects with simulation results

    Raises:

    """
    rdata_list = []
    for edata in edata_list:
        rdata = runAmiciSimulation(
            model,
            solver,
            edata,
        )
        rdata_list.append(rdata)

    return rdata_list


def rdataToNumPyArrays(rdata):
    """ Convenience wrapper ReturnData class (generated by swig) 

    Arguments:
        rdata: ReturnData instance with simulation results

    Returns:
        ReturnData object with numpy array fields

    Raises:
        
    """
    npReturnData = {'ptr': rdata}
    fieldNames = ['t', 'x', 'x0', 'sx', 'sx0', 'y', 'sigmay', 'sy', 'ssigmay',
                  'z', 'rz', 'sigmaz', 'sz', 'srz', 'ssigmaz', 'sllh', 's2llh',
                  'J', 'xdot', 'status', 'llh', 'chi2', 'res', 'sres', 'FIM',
                  'newton_numlinsteps', 'newton_numsteps',
                  'numsteps', 'numrhsevals', 'numerrtestfails', 'numnonlinsolvconvfails',
                  'order', 'numstepsB', 'numrhsevalsB', 'numerrtestfailsB', 'numnonlinsolvconvfailsB']

    for field in fieldNames:
        npReturnData[field] = getReturnDataFieldAsNumPyArray(rdata, field)

    return npReturnData


def edataToNumPyArrays(edata):
    """ Convenience wrapper ExpData class (generated by swig)

    Arguments:
        edata: ExpData instance with experimental data

    Returns:
        ExpData object with numpy array fields

    Raises:

    """
    npExpData = {'ptr': edata}

    fieldNames = ['observedData', 'observedDataStdDev', 'observedEvents', 'observedEventsStdDev', 'fixedParameters',
                  'fixedParametersPreequilibration']

    edata.observedData = edata.getObservedData()
    edata.observedDataStdDev = edata.getObservedDataStdDev()
    edata.observedEvents = edata.getObservedEvents()
    edata.observedEventsStdDev = edata.getObservedEventsStdDev()

    for field in fieldNames:
        npExpData[field] = getExpDataFieldAsNumPyArray(edata, field)

    return npExpData


def fieldAsNumpy(fieldDimensions, field, data):
    """ Convert data object field to numpy array with dimensions according to specified field dimensions

    Arguments:
        fieldDimensions: dimension specifications dict({field: list([dim1, dim2, ...])})
        data: object with fields
        field: Name of field

    Returns:
        Field Data as numpy array with dimensions according to specified field dimensions

    Raises:

    """
    attr = getattr(data, field)
    if field in fieldDimensions.keys():
        if len(attr) == 0:
            return None
        else:
            return stdVec2ndarray(attr, *fieldDimensions[field]).copy()
    else:
        return float(attr)


def getReturnDataFieldAsNumPyArray(rdata, field):
    """ Convert ReturnData field to numpy array with dimensions according to model dimensions in rdata

    Arguments:
        rdata: ReturnData instance with simulation results
        field: Name of field

    Returns:
        Field Data as numpy array with dimensions according to model dimensions in rdata

    Raises:

    """

    fieldDimensions = {'ts':  [rdata.nt],
                       'x':   [rdata.nt, rdata.nx],
                       'x0':  [rdata.nx],
                       'sx':  [rdata.nt, rdata.nplist, rdata.nx],
                       'sx0': [rdata.nplist, rdata.nx],

                       # observables
                       'y':       [rdata.nt, rdata.ny],
                       'sigmay':  [rdata.nt, rdata.ny],
                       'sy':      [rdata.nt, rdata.nplist, rdata.ny],
                       'ssigmay': [rdata.nt, rdata.nplist, rdata.ny],

                       # event observables
                       'z':       [rdata.nmaxevent, rdata.nz],
                       'rz':      [rdata.nmaxevent, rdata.nz],
                       'sigmaz':  [rdata.nmaxevent, rdata.nz],
                       'sz':      [rdata.nmaxevent, rdata.nplist, rdata.nz],
                       'srz':     [rdata.nmaxevent, rdata.nplist, rdata.nz],
                       'ssigmaz': [rdata.nmaxevent, rdata.nplist, rdata.nz],

                       # objective function
                       'sllh':  [rdata.nplist],
                       's2llh': [rdata.np, rdata.nplist],

                       'res':   [rdata.nt * rdata.nytrue],
                       'sres':  [rdata.nt * rdata.nytrue, rdata.nplist],
                       'FIM':   [rdata.nplist, rdata.nplist],

                       # diagnosis
                       'J':                       [rdata.nx, rdata.nx],
                       'xdot':                    [rdata.nx],
                       'newton_numlinsteps':      [rdata.newton_maxsteps, 2],
                       'newton_numsteps':         [1, 2],
                       'numsteps':                [rdata.nt],
                       'numrhsevals':             [rdata.nt],
                       'numerrtestfails':         [rdata.nt],
                       'numnonlinsolvconvfails':  [rdata.nt],
                       'order':                   [rdata.nt],
                       'numstepsB':               [rdata.nt],
                       'numrhsevalsB':            [rdata.nt],
                       'numerrtestfailsB':        [rdata.nt],
                       'numnonlinsolvconvfailsB': [rdata.nt],
                       }
    if field == 't':
        field = 'ts'

    return fieldAsNumpy(fieldDimensions, field, rdata)

def getExpDataFieldAsNumPyArray(edata, field):
    """ Convert ExpData field to numpy array with dimensions according to model dimensions in edata

    Arguments:
        edata: ExpData instance with experimental data
        field: Name of field

    Returns:
        Field Data as numpy array with dimensions according to model dimensions in edata

    Raises:

    """

    fieldDimensions = {# observables
                       'observedData': [edata.nt(), edata.nytrue],
                       'observedDataStdDev': [edata.nt(), edata.nytrue],

                       # event observables
                       'observedEvents': [edata.nmaxevent, edata.nztrue],
                       'observedEventsStdDev': [edata.nmaxevent, edata.nztrue],

                       # fixed parameters
                       'fixedParameters': [edata.fixedParameters.size()],
                       'fixedParametersPreequilibration': [edata.fixedParametersPreequilibration.size()],
                       }

    return fieldAsNumpy(fieldDimensions, field, edata)


def getDataObservablesAsDataFrame(model, edata_list):
    """ Write Observables from experimental data as DataFrame

    Arguments:
        model: Model instance
        edata_list: list of ExpData instances with experimental data

    Returns:
        pandas DataFrame with conditions and observables

    Raises:
        ImportError if pandas is not installed
    """

    if pd is None:
        raise ImportError('This function is only available if the pandas '
                          'package is installed')

    cols = _get_extended_observable_cols(model)
    df_edata = pd.DataFrame(columns=cols)

    for edata in edata_list:
        npdata = edataToNumPyArrays(edata)
        for i_time, timepoint in enumerate(edata.getTimepoints()):
            datadict = {
                'time': timepoint,
                'datatype': 'data'
            }
            for i_obs, obs in enumerate(_get_names_or_ids(model,
                                                          'Observable')):
                datadict[obs] = npdata['observedData'][i_time, i_obs]
                datadict[obs + '_std'] = npdata['observedDataStdDev'][
                    i_time, i_obs]

            _fill_conditions_dict(datadict, model, edata)

            df_edata.loc[len(df_edata)] = datadict

    return df_edata


def getSimulationObservablesAsDataFrame(model, edata_list, rdata_list):
    """ Write Observables from simulation results as DataFrame

    Arguments:
        model: Model instance
        edata_list: list of ExpData instances with experimental data
        rdata_list: list of ReturnData instances corresponding to ExpData

    Returns:
        pandas DataFrame with conditions and observables

    Raises:
        ImportError if pandas is not installed
    """
    if pd is None:
        raise ImportError('This function is only available if the pandas '
                          'package is installed')

    cols = _get_extended_observable_cols(model)
    df_rdata = pd.DataFrame(columns=cols)

    for edata, rdata in zip(edata_list, rdata_list):
        for i_time, timepoint in enumerate(rdata['t']):
            datadict = {
                'time': timepoint,
                'datatype': 'simulation',
            }
            for i_obs, obs in enumerate(_get_names_or_ids(model,
                                                          'Observable')):
                datadict[obs] = rdata['y'][i_time, i_obs]
                datadict[obs + '_std'] = rdata['sigmay'][i_time, i_obs]

            _fill_conditions_dict(datadict, model, edata)

            df_rdata.loc[len(df_rdata)] = datadict

    return df_rdata


def getSimulationStatesAsDataFrame(model, edata_list, rdata_list):
    """ Compute model residuals according to a list of ReturnData and ExpData

    Arguments:
        model: Model instance
        edata_list: list of ExpData instances with experimental data
        rdata_list: list of ReturnData instances corresponding to ExpData

    Returns:
        pandas DataFrame with conditions and observables

    Raises:
        ImportError if pandas is not installed
    """
    if pd is None:
        raise ImportError('This function is only available if the pandas '
                          'package is installed')

    cols = _get_state_cols(model)
    df_rdata = pd.DataFrame(columns=cols)

    for edata, rdata in zip(edata_list, rdata_list):
        for i_time, timepoint in enumerate(rdata['t']):
            datadict = {
                'time': timepoint,
            }

            for i_state, state in enumerate(_get_names_or_ids(model, 'State')):
                datadict[state] = rdata['x'][i_time, i_state]

            _fill_conditions_dict(datadict, model, edata)

            df_rdata.loc[len(df_rdata)] = datadict
    return df_rdata


def getResidualsAsDataFrame(model, edata_list, rdata_list):
    """ Convert a list of ExpData to pandas DataFrame

    Arguments:
        model: Model instance
        edata_list: list of ExpData instances with experimental data
        rdata_list: list of ReturnData instances corresponding to ExpData

    Returns:
        pandas DataFrame with conditions and observables

    Raises:
        ImportError if pandas is not installed
    """
    if pd is None:
        raise ImportError('This function is only available if the pandas '
                          'package is installed')

    df_edata = getDataObservablesAsDataFrame(model, edata_list)
    df_rdata = getSimulationObservablesAsDataFrame(model, edata_list, rdata_list)

    cols = _get_observable_cols(model)

    df_res = pd.DataFrame(columns=cols)

    for row in df_rdata.index:
        datadict = {
            'time': df_rdata.loc[row]['time'],
            't_presim': df_rdata.loc[row]['t_presim']
        }
        for obs in _get_names_or_ids(model, 'Observable'):
            datadict[obs] = abs(
                (df_edata.loc[row][obs] - df_rdata.loc[row][obs]) /
                df_rdata.loc[row][obs + '_std'])
        for par in _get_names_or_ids(model, 'FixedParameter'):
            datadict[par] = df_rdata.loc[row][par]
            datadict[par + '_preeq'] = df_rdata.loc[row][par + '_preeq']
            datadict[par + '_presim'] = df_rdata.loc[row][par + '_presim']
        df_res.loc[len(df_res)] = datadict

    return df_res


def _fill_conditions_dict(datadict, model, edata) -> dict:
    """ Helper function that fills in condition parameters from model and edata

    Arguments:
        datadict: dictionary in which condition parameters will be inserted
        as key value pairs
        model: Model instance
        edata: ExpData instance

    Returns:
        dictionary with filled condition parameters

    Raises:

    """
    datadict['t_presim'] = edata.t_presim
    
    for i_par, par in enumerate(_get_names_or_ids(model, 'FixedParameter')):
        if edata.fixedParameters.size():
            datadict[par] = edata.fixedParameters[i_par]
        else:
            datadict[par] = model.getFixedParameters()[i_par]

        if edata.fixedParametersPreequilibration.size():
            datadict[par + '_preeq'] = \
                edata.fixedParametersPreequilibration[i_par]
        else:
            datadict[par + '_preeq'] = np.nan

        if edata.fixedParametersPresimulation.size():
            datadict[par + '_presim'] = \
                edata.fixedParametersPresimulation[i_par]
        else:
            datadict[par + '_presim'] = np.nan
    return datadict


def _get_extended_observable_cols(model) -> list:
    """ Construction helper for extended observable dataframe headers

    Arguments:
        model: Model instance

    Returns:
        column names as list

    Raises:

    """
    return \
        ['time', 'datatype','t_presim'] + \
        _get_names_or_ids(model, 'FixedParameter') + \
        [name + '_preeq' for name in _get_names_or_ids(model, 'FixedParameter')] + \
        [name + '_presim' for name in _get_names_or_ids(model, 'FixedParameter')] + \
        _get_names_or_ids(model, 'Observable') + \
        [name + '_std' for name in _get_names_or_ids(model, 'Observable')]


def _get_observable_cols(model):
    """ Construction helper for observable dataframe headers

    Arguments:
        model: Model instance

    Returns:
        column names as list

    Raises:

    """
    return \
        ['time','t_presim'] + \
        _get_names_or_ids(model, 'FixedParameter') + \
        [name + '_preeq' for name in _get_names_or_ids(model, 'FixedParameter')] + \
        [name + '_presim' for name in _get_names_or_ids(model, 'FixedParameter')] + \
        _get_names_or_ids(model, 'Observable')


def _get_state_cols(model):
    """ Construction helper for state dataframe headers

    Arguments:
        model: Model instance

    Returns:
        column names as list

    Raises:

    """
    return \
        ['time','t_presim'] + \
        _get_names_or_ids(model, 'FixedParameter') + \
        [name + '_preeq' for name in _get_names_or_ids(model, 'FixedParameter')] + \
        [name + '_presim' for name in _get_names_or_ids(model, 'FixedParameter')] + \
        _get_names_or_ids(model, 'State')


def _get_names_or_ids(model, variable):
    """ Obtains a unique list of identifiers for the specified variable
        first tries model.getVariableNames and then uses model.getVariableIds

    Arguments:
        model: Model instance
        variable: variable name

    Returns:
        column names as list

    Raises:

    """
    variable_options = ['Parameter','FixedParameter','Observable','State']
    if variable not in variable_options:
        raise ValueError('variable must be in ' + str(variable_options))
    namegetter = getattr(model, 'get' + variable + 'Names')
    idgetter = getattr(model, 'get' + variable + 'Ids')
    if set(namegetter()) == len(namegetter()):
        return list(namegetter())
    else:
        return list(idgetter())


def _get_specialized_fixed_parameters(model, condition, overwrite) -> list:
    """ Copies values in condition and overwrites them according to key
    value pairs specified in overwrite

    Arguments:
        model: Model instance
        condition: dict/pd.Series containing FixedParameter values
        overwrite: dict specifying which values in condition are to be replaced

    Returns:
        overwritten FixedParameter as list

    Raises:

    """
    cond = copy.deepcopy(condition)
    for field in overwrite:
        cond[field] = overwrite[field]
    return [cond[name] for name in _get_names_or_ids(model, 'FixedParameter')]


def constructEdataFromDataFrame(df, model, condition):
    """ Constructs an ExpData instance according to the provided Model and DataFrame

    Arguments:
        df: pd.DataFrame with Observable Names/Ids as columns
            standard deviations may be specified by appending '_std' as suffix
        model: Model instance
        condition: pd.Series with FixedParameter Names/Ids as columns
            preequilibration conditions may be specified by appending '_preeq' as suffix
            presimulation conditions may be specified by appending '_presim' as suffix

    Returns:
        ExpData instance

    Raises:

    """
    edata = amici.ExpData(model.get())

    # timepoints
    df = df.sort_values(by='time',ascending=True)
    edata.setTimepoints(amici.DoubleVector(df['time'].values))

    overwrite_preeq = {}
    overwrite_presim = {}
    for par in list(_get_names_or_ids(model, 'FixedParameter')):
        if par + '_preeq' in condition.keys() \
                and not math.isnan(condition[par + '_preeq']):
            overwrite_preeq[par] = condition[par + '_preeq']
        if par + '_presim' in condition.keys() \
                and not math.isnan(condition[par + '_presim']):
            overwrite_presim[par] = condition[par + '_presim']

    # fixedParameters
    edata.fixedParameters = amici.DoubleVector(
        condition[_get_names_or_ids(model, 'FixedParameter')].values
    )

    if any([overwrite_preeq[key] != condition[key] for key in overwrite_preeq.keys()]):
        edata.fixedParametersPreequilibration = amici.DoubleVector(
            _get_specialized_fixed_parameters(model, condition, overwrite_preeq)
        )

    if any([overwrite_presim[key] != condition[key] for key in overwrite_presim.keys()]):
        edata.fixedParametersPresimulation = amici.DoubleVector(
            _get_specialized_fixed_parameters(model, condition, overwrite_presim)
        )

    if 't_presim' in condition.keys():
        edata.t_presim = condition['t_presim']

    # data
    for obs_index, obs in enumerate(_get_names_or_ids(model, 'Observable')):
        if obs in df.keys():
            edata.setObservedData(amici.DoubleVector(df[obs].values), obs_index)
        if obs + '_std' in df.keys():
            edata.setObservedDataStdDev(
                amici.DoubleVector(df[obs + '_std'].values),
                obs_index
            )

    return edata


def getEdataFromDataFrame(model, df):
    """ Constructs a ExpData instance according to the provided Model and DataFrame

    Arguments:
        df: pd.DataFrame with Observable Names/Ids, FixedParameter Names/Ids and time as columns
            standard deviations may be specified by appending '_std' as suffix
            preequilibration fixedParameters may be specified by appending '_preeq' as suffix
            presimulation fixedParameters may be specified by appending '_presim' as suffix
            presimulation time may be specified as 't_presim' column
        model: Model instance

    Returns:
        ExpData instance

    Raises:

    """
    edata_list = []
    # aggregate features that define a condition
    condition_parameters = _get_names_or_ids(model, 'FixedParameter')
    for par in _get_names_or_ids(model, 'FixedParameter'):
        if par + '_preeq' in df.columns:
            condition_parameters.append(par + '_preeq')
        if par + '_presim' in df.columns:
            condition_parameters.append(par + '_presim')
    if 't_presim' in df.columns:
            condition_parameters.append('t_presim')
    conditions = df[condition_parameters].drop_duplicates()

    for row in conditions.iterrows():
        # subselect rows that match condition
        selected = np.ones((len(df),), dtype=bool)
        for par_label, par in row[1].iteritems():
            if math.isnan(par):
                selected = selected & np.isnan(df[par_label].values)
            else:
                selected = selected & (df[par_label] == par)
        edata_df = df[selected]

        edata_list.append(constructEdataFromDataFrame(edata_df, model, row[1]))

    return edata_list